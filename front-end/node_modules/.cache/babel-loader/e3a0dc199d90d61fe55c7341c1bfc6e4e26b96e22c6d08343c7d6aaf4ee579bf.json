{"ast":null,"code":"var _jsxFileName = \"/Users/kietla92/travel-app/front-end/src/components/Globe.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport axios from \"axios\";\nimport CountryModal from \"./CountryModal\";\n\n// Define color constants\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DARK_GREEN = 0x006400; // Dark green for visited countries' outlines\nconst DARK_RED = 0x8b0000; // Dark red for unvisited countries' outlines\nconst GLOBE_COLOR = 0x87ceeb; // Sky blue for the globe background\nconst COUNTRY_COLOR = 0xcccccc; // Light grey for all countries' fill\n\nconst Globe = () => {\n  _s();\n  const globeRef = useRef();\n  const [geoJsonCountries, setGeoJsonCountries] = useState([]);\n  const [countriesData, setCountriesData] = useState([]);\n  const [selectedCountry, setSelectedCountry] = useState(null);\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n  const isDragging = useRef(false);\n  const clickStart = useRef(null);\n  useEffect(() => {\n    axios.get(\"http://localhost:3000/countries\").then(response => {\n      setCountriesData(response.data);\n    }).catch(error => {\n      console.error(\"Error fetching countries data:\", error);\n    });\n    fetch(\"/data/countries.geojson\").then(response => response.json()).then(geoData => {\n      setGeoJsonCountries(geoData.features);\n      if (!renderer.current && !scene.current && !camera.current) {\n        scene.current = new THREE.Scene();\n        camera.current = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        renderer.current = new THREE.WebGLRenderer();\n        renderer.current.setSize(window.innerWidth, window.innerHeight);\n        globeRef.current.appendChild(renderer.current.domElement);\n        const geometry = new THREE.SphereGeometry(5, 32, 32);\n        const material = new THREE.MeshBasicMaterial({\n          color: GLOBE_COLOR,\n          wireframe: false\n        });\n        globe.current = new THREE.Mesh(geometry, material);\n        scene.current.add(globe.current);\n        camera.current.position.z = 10;\n        const animate = () => {\n          requestAnimationFrame(animate);\n          if (!isDragging.current && globe.current) {\n            globe.current.rotation.y += 0.01;\n          }\n          renderer.current.render(scene.current, camera.current);\n        };\n        animate();\n      }\n    }).catch(error => {\n      console.error(\"Error loading GeoJSON:\", error);\n    });\n  }, []);\n  useEffect(() => {\n    // Only proceed if both geoJsonCountries and countriesData are loaded\n    if (geoJsonCountries.length > 0 && countriesData.length > 0) {\n      console.log(\"Both geoJsonCountries and countriesData are loaded.\");\n      mapCountriesToGlobe(geoJsonCountries);\n    } else {\n      console.log(\"Waiting for geoJsonCountries or countriesData to load...\");\n    }\n  }, [geoJsonCountries, countriesData]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = features => {\n    features.forEach(feature => {\n      const {\n        coordinates\n      } = feature.geometry;\n      let countryName = feature.properties.admin.trim().toLowerCase(); // Normalize GeoJSON country name\n\n      console.log(`GeoJSON countryName (admin): ${countryName}`);\n\n      // Check if this country exists in hardcoded countriesData\n      const country = countriesData.find(c => c.name.trim().toLowerCase() === countryName);\n\n      // Set color based on whether the country is visited or not\n      const countryColor = country && country.visited ? DARK_GREEN : DARK_RED;\n      console.log(`Coloring country: ${countryName} as ${countryColor === DARK_GREEN ? \"Dark Green\" : \"Dark Red\"}`);\n      const countryGroup = new THREE.Group();\n\n      // Render countries as polygons or multipolygons\n      if (feature.geometry.type === \"Polygon\") {\n        mapPolygonToGlobe(coordinates, countryGroup, countryColor);\n      } else if (feature.geometry.type === \"MultiPolygon\") {\n        coordinates.forEach(polygon => {\n          mapPolygonToGlobe(polygon, countryGroup, countryColor);\n        });\n      }\n      globe.current.add(countryGroup); // Add the country group to the globe\n    });\n  };\n\n  // Helper function to map a single polygon to the globe\n  const mapPolygonToGlobe = (polygon, countryGroup, countryColor) => {\n    polygon.forEach(coordSet => {\n      const points = [];\n      const backgroundPoints = [];\n      coordSet.forEach(([longitude, latitude]) => {\n        const phi = (90 - latitude) * (Math.PI / 180);\n        const theta = (longitude + 180) * (Math.PI / 180);\n\n        // Original point\n        const x = 5 * Math.sin(phi) * Math.cos(theta);\n        const y = 5 * Math.cos(phi);\n        const z = 5 * Math.sin(phi) * Math.sin(theta);\n        points.push(new THREE.Vector3(x, y, z));\n\n        // Slightly larger point for background\n        const bgX = 5.02 * Math.sin(phi) * Math.cos(theta);\n        const bgY = 5.02 * Math.cos(phi);\n        const bgZ = 5.02 * Math.sin(phi) * Math.sin(theta);\n        backgroundPoints.push(new THREE.Vector3(bgX, bgY, bgZ));\n      });\n\n      // Create background\n      const bgGeometry = new THREE.BufferGeometry().setFromPoints(backgroundPoints);\n      const bgMaterial = new THREE.MeshBasicMaterial({\n        color: countryColor,\n        side: THREE.DoubleSide,\n        transparent: true,\n        opacity: 0.5 // Increased opacity for better visibility\n      });\n      const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);\n      countryGroup.add(bgMesh);\n\n      // Create outline\n      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n      const lineMaterial = new THREE.LineBasicMaterial({\n        color: countryColor,\n        linewidth: 2\n      });\n      const line = new THREE.Line(lineGeometry, lineMaterial);\n      countryGroup.add(line);\n    });\n  };\n\n  // Mouse interaction handlers\n  const handleMouseDown = event => {\n    isDragging.current = false;\n    clickStart.current = {\n      x: event.clientX,\n      y: event.clientY\n    };\n  };\n  const handleMouseMove = event => {\n    if (!clickStart.current || !globe.current) return; // Check if globe is initialized\n\n    const deltaMove = {\n      x: event.clientX - clickStart.current.x,\n      y: event.clientY - clickStart.current.y\n    };\n    if (Math.abs(deltaMove.x) > 2 || Math.abs(deltaMove.y) > 2) {\n      isDragging.current = true;\n      globe.current.rotation.y += deltaMove.x * 0.005;\n      globe.current.rotation.x += deltaMove.y * 0.005;\n      clickStart.current = {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  };\n  const handleMouseUp = event => {\n    if (!isDragging.current && globe.current) {\n      const mouse = {\n        x: event.clientX / window.innerWidth * 2 - 1,\n        y: -(event.clientY / window.innerHeight) * 2 + 1\n      };\n      raycaster.setFromCamera(mouse, camera.current);\n      const intersects = raycaster.intersectObjects(scene.current.children, true);\n      if (intersects.length > 0) {\n        const clickedObject = intersects[0].object;\n        if (clickedObject && clickedObject.userData && clickedObject.userData.isCountry) {\n          const countryId = clickedObject.userData.id; // Get the country ID from userData\n\n          // Find the country in the fetched countries data\n          const country = countriesData.find(c => c.id === countryId);\n          if (country) {\n            setSelectedCountry(country); // Show country details in modal\n          }\n        }\n      }\n    }\n    clickStart.current = null;\n    isDragging.current = false;\n  };\n  window.addEventListener(\"mousedown\", handleMouseDown);\n  window.addEventListener(\"mousemove\", handleMouseMove);\n  window.addEventListener(\"mouseup\", handleMouseUp);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      ref: globeRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CountryModal, {\n      isOpen: !!selectedCountry,\n      countryData: selectedCountry,\n      onClose: () => setSelectedCountry(null)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 242,\n    columnNumber: 5\n  }, this);\n};\n_s(Globe, \"dQSLz5AT0KccWRv/m3DplejZdZ4=\");\n_c = Globe;\nexport default Globe;\nvar _c;\n$RefreshReg$(_c, \"Globe\");","map":{"version":3,"names":["React","useEffect","useRef","useState","THREE","axios","CountryModal","jsxDEV","_jsxDEV","DARK_GREEN","DARK_RED","GLOBE_COLOR","COUNTRY_COLOR","Globe","_s","globeRef","geoJsonCountries","setGeoJsonCountries","countriesData","setCountriesData","selectedCountry","setSelectedCountry","raycaster","Raycaster","mouse","Vector2","renderer","scene","camera","globe","isDragging","clickStart","get","then","response","data","catch","error","console","fetch","json","geoData","features","current","Scene","PerspectiveCamera","window","innerWidth","innerHeight","WebGLRenderer","setSize","appendChild","domElement","geometry","SphereGeometry","material","MeshBasicMaterial","color","wireframe","Mesh","add","position","z","animate","requestAnimationFrame","rotation","y","render","length","log","mapCountriesToGlobe","forEach","feature","coordinates","countryName","properties","admin","trim","toLowerCase","country","find","c","name","countryColor","visited","countryGroup","Group","type","mapPolygonToGlobe","polygon","coordSet","points","backgroundPoints","longitude","latitude","phi","Math","PI","theta","x","sin","cos","push","Vector3","bgX","bgY","bgZ","bgGeometry","BufferGeometry","setFromPoints","bgMaterial","side","DoubleSide","transparent","opacity","bgMesh","lineGeometry","lineMaterial","LineBasicMaterial","linewidth","line","Line","handleMouseDown","event","clientX","clientY","handleMouseMove","deltaMove","abs","handleMouseUp","setFromCamera","intersects","intersectObjects","children","clickedObject","object","userData","isCountry","countryId","id","addEventListener","ref","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","countryData","onClose","_c","$RefreshReg$"],"sources":["/Users/kietla92/travel-app/front-end/src/components/Globe.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport axios from \"axios\";\nimport CountryModal from \"./CountryModal\";\n\n// Define color constants\nconst DARK_GREEN = 0x006400; // Dark green for visited countries' outlines\nconst DARK_RED = 0x8b0000; // Dark red for unvisited countries' outlines\nconst GLOBE_COLOR = 0x87ceeb; // Sky blue for the globe background\nconst COUNTRY_COLOR = 0xcccccc; // Light grey for all countries' fill\n\nconst Globe = () => {\n  const globeRef = useRef();\n  const [geoJsonCountries, setGeoJsonCountries] = useState([]);\n  const [countriesData, setCountriesData] = useState([]);\n  const [selectedCountry, setSelectedCountry] = useState(null);\n\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n  const isDragging = useRef(false);\n  const clickStart = useRef(null);\n\n  useEffect(() => {\n    axios\n      .get(\"http://localhost:3000/countries\")\n      .then((response) => {\n        setCountriesData(response.data);\n      })\n      .catch((error) => {\n        console.error(\"Error fetching countries data:\", error);\n      });\n\n    fetch(\"/data/countries.geojson\")\n      .then((response) => response.json())\n      .then((geoData) => {\n        setGeoJsonCountries(geoData.features);\n\n        if (!renderer.current && !scene.current && !camera.current) {\n          scene.current = new THREE.Scene();\n          camera.current = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n          );\n          renderer.current = new THREE.WebGLRenderer();\n          renderer.current.setSize(window.innerWidth, window.innerHeight);\n          globeRef.current.appendChild(renderer.current.domElement);\n\n          const geometry = new THREE.SphereGeometry(5, 32, 32);\n          const material = new THREE.MeshBasicMaterial({\n            color: GLOBE_COLOR,\n            wireframe: false,\n          });\n          globe.current = new THREE.Mesh(geometry, material);\n          scene.current.add(globe.current);\n\n          camera.current.position.z = 10;\n\n          const animate = () => {\n            requestAnimationFrame(animate);\n            if (!isDragging.current && globe.current) {\n              globe.current.rotation.y += 0.01;\n            }\n            renderer.current.render(scene.current, camera.current);\n          };\n          animate();\n        }\n      })\n      .catch((error) => {\n        console.error(\"Error loading GeoJSON:\", error);\n      });\n  }, []);\n\n  useEffect(() => {\n    // Only proceed if both geoJsonCountries and countriesData are loaded\n    if (geoJsonCountries.length > 0 && countriesData.length > 0) {\n      console.log(\"Both geoJsonCountries and countriesData are loaded.\");\n      mapCountriesToGlobe(geoJsonCountries);\n    } else {\n      console.log(\"Waiting for geoJsonCountries or countriesData to load...\");\n    }\n  }, [geoJsonCountries, countriesData]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = (features) => {\n    features.forEach((feature) => {\n      const { coordinates } = feature.geometry;\n      let countryName = feature.properties.admin.trim().toLowerCase(); // Normalize GeoJSON country name\n\n      console.log(`GeoJSON countryName (admin): ${countryName}`);\n\n      // Check if this country exists in hardcoded countriesData\n      const country = countriesData.find(\n        (c) => c.name.trim().toLowerCase() === countryName\n      );\n\n      // Set color based on whether the country is visited or not\n      const countryColor = country && country.visited ? DARK_GREEN : DARK_RED;\n      console.log(\n        `Coloring country: ${countryName} as ${\n          countryColor === DARK_GREEN ? \"Dark Green\" : \"Dark Red\"\n        }`\n      );\n\n      const countryGroup = new THREE.Group();\n\n      // Render countries as polygons or multipolygons\n      if (feature.geometry.type === \"Polygon\") {\n        mapPolygonToGlobe(coordinates, countryGroup, countryColor);\n      } else if (feature.geometry.type === \"MultiPolygon\") {\n        coordinates.forEach((polygon) => {\n          mapPolygonToGlobe(polygon, countryGroup, countryColor);\n        });\n      }\n\n      globe.current.add(countryGroup); // Add the country group to the globe\n    });\n  };\n\n  // Helper function to map a single polygon to the globe\n  const mapPolygonToGlobe = (polygon, countryGroup, countryColor) => {\n    polygon.forEach((coordSet) => {\n      const points = [];\n      const backgroundPoints = [];\n\n      coordSet.forEach(([longitude, latitude]) => {\n        const phi = (90 - latitude) * (Math.PI / 180);\n        const theta = (longitude + 180) * (Math.PI / 180);\n\n        // Original point\n        const x = 5 * Math.sin(phi) * Math.cos(theta);\n        const y = 5 * Math.cos(phi);\n        const z = 5 * Math.sin(phi) * Math.sin(theta);\n        points.push(new THREE.Vector3(x, y, z));\n\n        // Slightly larger point for background\n        const bgX = 5.02 * Math.sin(phi) * Math.cos(theta);\n        const bgY = 5.02 * Math.cos(phi);\n        const bgZ = 5.02 * Math.sin(phi) * Math.sin(theta);\n        backgroundPoints.push(new THREE.Vector3(bgX, bgY, bgZ));\n      });\n\n      // Create background\n      const bgGeometry = new THREE.BufferGeometry().setFromPoints(\n        backgroundPoints\n      );\n      const bgMaterial = new THREE.MeshBasicMaterial({\n        color: countryColor,\n        side: THREE.DoubleSide,\n        transparent: true,\n        opacity: 0.5, // Increased opacity for better visibility\n      });\n      const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);\n      countryGroup.add(bgMesh);\n\n      // Create outline\n      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n      const lineMaterial = new THREE.LineBasicMaterial({\n        color: countryColor,\n        linewidth: 2,\n      });\n      const line = new THREE.Line(lineGeometry, lineMaterial);\n      countryGroup.add(line);\n    });\n  };\n\n  // Mouse interaction handlers\n  const handleMouseDown = (event) => {\n    isDragging.current = false;\n    clickStart.current = {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  };\n\n  const handleMouseMove = (event) => {\n    if (!clickStart.current || !globe.current) return; // Check if globe is initialized\n\n    const deltaMove = {\n      x: event.clientX - clickStart.current.x,\n      y: event.clientY - clickStart.current.y,\n    };\n\n    if (Math.abs(deltaMove.x) > 2 || Math.abs(deltaMove.y) > 2) {\n      isDragging.current = true;\n      globe.current.rotation.y += deltaMove.x * 0.005;\n      globe.current.rotation.x += deltaMove.y * 0.005;\n      clickStart.current = {\n        x: event.clientX,\n        y: event.clientY,\n      };\n    }\n  };\n\n  const handleMouseUp = (event) => {\n    if (!isDragging.current && globe.current) {\n      const mouse = {\n        x: (event.clientX / window.innerWidth) * 2 - 1,\n        y: -(event.clientY / window.innerHeight) * 2 + 1,\n      };\n      raycaster.setFromCamera(mouse, camera.current);\n\n      const intersects = raycaster.intersectObjects(\n        scene.current.children,\n        true\n      );\n      if (intersects.length > 0) {\n        const clickedObject = intersects[0].object;\n\n        if (\n          clickedObject &&\n          clickedObject.userData &&\n          clickedObject.userData.isCountry\n        ) {\n          const countryId = clickedObject.userData.id; // Get the country ID from userData\n\n          // Find the country in the fetched countries data\n          const country = countriesData.find((c) => c.id === countryId);\n\n          if (country) {\n            setSelectedCountry(country); // Show country details in modal\n          }\n        }\n      }\n    }\n\n    clickStart.current = null;\n    isDragging.current = false;\n  };\n\n  window.addEventListener(\"mousedown\", handleMouseDown);\n  window.addEventListener(\"mousemove\", handleMouseMove);\n  window.addEventListener(\"mouseup\", handleMouseUp);\n\n  return (\n    <div>\n      <div ref={globeRef} />\n      <CountryModal\n        isOpen={!!selectedCountry}\n        countryData={selectedCountry}\n        onClose={() => setSelectedCountry(null)}\n      />\n    </div>\n  );\n};\n\nexport default Globe;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}