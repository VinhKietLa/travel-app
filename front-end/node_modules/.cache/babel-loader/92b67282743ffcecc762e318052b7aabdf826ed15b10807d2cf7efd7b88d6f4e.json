{"ast":null,"code":"var _jsxFileName = \"/Users/kietla92/travel-app/front-end/src/components/Globe.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport CountryModal from \"./CountryModal\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Globe = () => {\n  _s();\n  const globeRef = useRef();\n  const [countries, setCountries] = useState([]);\n  const [selectedCountry, setSelectedCountry] = useState(null);\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n\n  // Use useRef to persist these objects across renders\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n  useEffect(() => {\n    // Load the GeoJSON file for country borders\n    fetch(\"/data/countries.geojson\").then(response => response.json()).then(geoData => {\n      setCountries(geoData.features); // Save the GeoJSON country features\n\n      // Set up the Three.js scene (ensure it's only set up once)\n      if (!renderer.current && !scene.current && !camera.current) {\n        scene.current = new THREE.Scene();\n        camera.current = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        renderer.current = new THREE.WebGLRenderer();\n        renderer.current.setSize(window.innerWidth, window.innerHeight);\n        globeRef.current.appendChild(renderer.current.domElement);\n\n        // Create a sphere for the globe\n        const geometry = new THREE.SphereGeometry(5, 32, 32);\n        const material = new THREE.MeshBasicMaterial({\n          color: 0x87ceeb,\n          // Sky-blue color for the earth\n          wireframe: false\n        });\n        globe.current = new THREE.Mesh(geometry, material);\n        scene.current.add(globe.current);\n        camera.current.position.z = 10;\n\n        // Map country borders onto the globe\n        mapCountriesToGlobe(geoData.features);\n\n        // Animation function to spin the globe\n        const animate = () => {\n          requestAnimationFrame(animate);\n          globe.current.rotation.y += 0.01; // Rotate the globe slowly\n          renderer.current.render(scene.current, camera.current);\n        };\n        animate();\n      }\n    }).catch(error => {\n      console.error(\"Error loading GeoJSON:\", error);\n    });\n\n    // Detect clicks on the globe\n    const handleMouseClick = event => {\n      mouse.x = event.clientX / window.innerWidth * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n      raycaster.setFromCamera(mouse, camera.current);\n      const intersects = raycaster.intersectObjects(scene.current.children);\n      if (intersects.length > 0) {\n        const clickedCountry = countries[0]; // For now, simulate clicking the first country (Japan)\n        setSelectedCountry(clickedCountry); // Set this as the selected country\n      }\n    };\n    window.addEventListener(\"click\", handleMouseClick);\n\n    // Clean up event listener on unmount\n    return () => {\n      window.removeEventListener(\"click\", handleMouseClick);\n    };\n  }, [countries]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = features => {\n    features.forEach(feature => {\n      const {\n        coordinates\n      } = feature.geometry;\n      const countryGroup = new THREE.Group();\n      coordinates.forEach(polygon => {\n        polygon.forEach(coordSet => {\n          const shape = new THREE.Shape();\n          coordSet.forEach(([longitude, latitude], index) => {\n            // Convert latitude and longitude to 3D coordinates\n            const phi = (90 - latitude) * (Math.PI / 180);\n            const theta = (longitude + 180) * (Math.PI / 180);\n            const x = 5 * Math.sin(phi) * Math.cos(theta);\n            const y = 5 * Math.cos(phi);\n            const z = 5 * Math.sin(phi) * Math.sin(theta);\n            if (index === 0) {\n              shape.moveTo(x, y, z);\n            } else {\n              shape.lineTo(x, y, z);\n            }\n          });\n          const geometry = new THREE.ShapeGeometry(shape);\n          const material = new THREE.MeshBasicMaterial({\n            color: 0xffffff,\n            opacity: 0.8,\n            transparent: true\n          });\n          const mesh = new THREE.Mesh(geometry, material);\n          countryGroup.add(mesh);\n        });\n      });\n      globe.current.add(countryGroup);\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      ref: globeRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CountryModal, {\n      isOpen: !!selectedCountry,\n      countryData: selectedCountry,\n      onClose: () => setSelectedCountry(null)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 128,\n    columnNumber: 5\n  }, this);\n};\n_s(Globe, \"dbzJ7erEu/zk3HFnfW/Yo2h9SN0=\");\n_c = Globe;\nexport default Globe;\nvar _c;\n$RefreshReg$(_c, \"Globe\");","map":{"version":3,"names":["React","useEffect","useRef","useState","THREE","CountryModal","jsxDEV","_jsxDEV","Globe","_s","globeRef","countries","setCountries","selectedCountry","setSelectedCountry","raycaster","Raycaster","mouse","Vector2","renderer","scene","camera","globe","fetch","then","response","json","geoData","features","current","Scene","PerspectiveCamera","window","innerWidth","innerHeight","WebGLRenderer","setSize","appendChild","domElement","geometry","SphereGeometry","material","MeshBasicMaterial","color","wireframe","Mesh","add","position","z","mapCountriesToGlobe","animate","requestAnimationFrame","rotation","y","render","catch","error","console","handleMouseClick","event","x","clientX","clientY","setFromCamera","intersects","intersectObjects","children","length","clickedCountry","addEventListener","removeEventListener","forEach","feature","coordinates","countryGroup","Group","polygon","coordSet","shape","Shape","longitude","latitude","index","phi","Math","PI","theta","sin","cos","moveTo","lineTo","ShapeGeometry","opacity","transparent","mesh","ref","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","countryData","onClose","_c","$RefreshReg$"],"sources":["/Users/kietla92/travel-app/front-end/src/components/Globe.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport CountryModal from \"./CountryModal\";\n\nconst Globe = () => {\n  const globeRef = useRef();\n  const [countries, setCountries] = useState([]);\n  const [selectedCountry, setSelectedCountry] = useState(null);\n\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n\n  // Use useRef to persist these objects across renders\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n\n  useEffect(() => {\n    // Load the GeoJSON file for country borders\n    fetch(\"/data/countries.geojson\")\n      .then((response) => response.json())\n      .then((geoData) => {\n        setCountries(geoData.features); // Save the GeoJSON country features\n\n        // Set up the Three.js scene (ensure it's only set up once)\n        if (!renderer.current && !scene.current && !camera.current) {\n          scene.current = new THREE.Scene();\n          camera.current = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n          );\n          renderer.current = new THREE.WebGLRenderer();\n          renderer.current.setSize(window.innerWidth, window.innerHeight);\n          globeRef.current.appendChild(renderer.current.domElement);\n\n          // Create a sphere for the globe\n          const geometry = new THREE.SphereGeometry(5, 32, 32);\n          const material = new THREE.MeshBasicMaterial({\n            color: 0x87ceeb, // Sky-blue color for the earth\n            wireframe: false,\n          });\n          globe.current = new THREE.Mesh(geometry, material);\n          scene.current.add(globe.current);\n\n          camera.current.position.z = 10;\n\n          // Map country borders onto the globe\n          mapCountriesToGlobe(geoData.features);\n\n          // Animation function to spin the globe\n          const animate = () => {\n            requestAnimationFrame(animate);\n            globe.current.rotation.y += 0.01; // Rotate the globe slowly\n            renderer.current.render(scene.current, camera.current);\n          };\n          animate();\n        }\n      })\n      .catch((error) => {\n        console.error(\"Error loading GeoJSON:\", error);\n      });\n\n    // Detect clicks on the globe\n    const handleMouseClick = (event) => {\n      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n      raycaster.setFromCamera(mouse, camera.current);\n\n      const intersects = raycaster.intersectObjects(scene.current.children);\n      if (intersects.length > 0) {\n        const clickedCountry = countries[0]; // For now, simulate clicking the first country (Japan)\n        setSelectedCountry(clickedCountry); // Set this as the selected country\n      }\n    };\n\n    window.addEventListener(\"click\", handleMouseClick);\n\n    // Clean up event listener on unmount\n    return () => {\n      window.removeEventListener(\"click\", handleMouseClick);\n    };\n  }, [countries]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = (features) => {\n    features.forEach((feature) => {\n      const { coordinates } = feature.geometry;\n      const countryGroup = new THREE.Group();\n\n      coordinates.forEach((polygon) => {\n        polygon.forEach((coordSet) => {\n          const shape = new THREE.Shape();\n          coordSet.forEach(([longitude, latitude], index) => {\n            // Convert latitude and longitude to 3D coordinates\n            const phi = (90 - latitude) * (Math.PI / 180);\n            const theta = (longitude + 180) * (Math.PI / 180);\n\n            const x = 5 * Math.sin(phi) * Math.cos(theta);\n            const y = 5 * Math.cos(phi);\n            const z = 5 * Math.sin(phi) * Math.sin(theta);\n\n            if (index === 0) {\n              shape.moveTo(x, y, z);\n            } else {\n              shape.lineTo(x, y, z);\n            }\n          });\n\n          const geometry = new THREE.ShapeGeometry(shape);\n          const material = new THREE.MeshBasicMaterial({\n            color: 0xffffff,\n            opacity: 0.8,\n            transparent: true,\n          });\n          const mesh = new THREE.Mesh(geometry, material);\n          countryGroup.add(mesh);\n        });\n      });\n\n      globe.current.add(countryGroup);\n    });\n  };\n\n  return (\n    <div>\n      <div ref={globeRef} />\n      <CountryModal\n        isOpen={!!selectedCountry}\n        countryData={selectedCountry}\n        onClose={() => setSelectedCountry(null)}\n      />\n    </div>\n  );\n};\n\nexport default Globe;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}