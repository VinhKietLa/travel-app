{"ast":null,"code":"var _jsxFileName = \"/Users/kietla92/travel-app/front-end/src/components/Globe.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport axios from \"axios\"; // Ensure axios is installed\nimport CountryModal from \"./CountryModal\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Globe = () => {\n  _s();\n  const globeRef = useRef();\n  const [geoJsonCountries, setGeoJsonCountries] = useState([]); // GeoJSON data for globe rendering\n  const [countriesData, setCountriesData] = useState([]); // Detailed data from backend\n  const [selectedCountry, setSelectedCountry] = useState(null);\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n  const isDragging = useRef(false);\n  const clickStart = useRef(null);\n  useEffect(() => {\n    // Fetch country details (hardcoded data) from the backend\n    axios.get(\"http://localhost:3000/countries\").then(response => {\n      console.log(\"Fetched countriesData:\", response.data); // Log countriesData to check if it's loaded\n      console.log(\"Hardcoded country names:\", countriesData.map(c => c.name.toLowerCase().trim()));\n      setCountriesData(response.data); // Store the detailed countries data from the backend\n    }).catch(error => {\n      console.error(\"Error fetching countries data:\", error);\n    });\n\n    // Load the GeoJSON file for country borders (for globe rendering)\n    fetch(\"/data/countries.geojson\").then(response => response.json()).then(geoData => {\n      console.log(\"Loaded GeoJSON:\", geoData.features); // Add this to log GeoJSON data\n      setGeoJsonCountries(geoData.features); // Store GeoJSON data\n\n      if (!renderer.current && !scene.current && !camera.current) {\n        scene.current = new THREE.Scene();\n        camera.current = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        renderer.current = new THREE.WebGLRenderer();\n        renderer.current.setSize(window.innerWidth, window.innerHeight);\n        globeRef.current.appendChild(renderer.current.domElement);\n        const geometry = new THREE.SphereGeometry(5, 32, 32);\n        const material = new THREE.MeshBasicMaterial({\n          color: 0x87ceeb,\n          wireframe: false\n        });\n        globe.current = new THREE.Mesh(geometry, material);\n        scene.current.add(globe.current);\n        camera.current.position.z = 10;\n        mapCountriesToGlobe(geoData.features); // Map GeoJSON data to the globe\n\n        const animate = () => {\n          requestAnimationFrame(animate);\n          if (!isDragging.current) {\n            globe.current.rotation.y += 0.01;\n          }\n          renderer.current.render(scene.current, camera.current);\n        };\n        animate();\n      }\n    }).catch(error => {\n      console.error(\"Error loading GeoJSON:\", error);\n    });\n\n    // Mouse interaction handlers\n    const handleMouseDown = event => {\n      isDragging.current = false;\n      clickStart.current = {\n        x: event.clientX,\n        y: event.clientY\n      };\n    };\n    const handleMouseMove = event => {\n      if (!clickStart.current) return;\n      const deltaMove = {\n        x: event.clientX - clickStart.current.x,\n        y: event.clientY - clickStart.current.y\n      };\n      if (Math.abs(deltaMove.x) > 2 || Math.abs(deltaMove.y) > 2) {\n        isDragging.current = true;\n        globe.current.rotation.y += deltaMove.x * 0.005;\n        globe.current.rotation.x += deltaMove.y * 0.005;\n        clickStart.current = {\n          x: event.clientX,\n          y: event.clientY\n        };\n      }\n    };\n    const handleMouseUp = event => {\n      if (!isDragging.current) {\n        const mouse = {\n          x: event.clientX / window.innerWidth * 2 - 1,\n          y: -(event.clientY / window.innerHeight) * 2 + 1\n        };\n        raycaster.setFromCamera(mouse, camera.current);\n        const intersects = raycaster.intersectObjects(scene.current.children, true);\n        if (intersects.length > 0) {\n          const clickedObject = intersects[0].object;\n          if (clickedObject && clickedObject.userData && clickedObject.userData.isCountry) {\n            const countryId = clickedObject.userData.id; // Get the country ID from userData\n\n            // Find the country in the fetched countries data\n            const country = countriesData.find(c => c.id === countryId);\n            if (country) {\n              setSelectedCountry(country); // Show country details in modal\n            }\n          }\n        }\n      }\n      clickStart.current = null;\n      isDragging.current = false;\n    };\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [countriesData]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = features => {\n    features.forEach(feature => {\n      const {\n        coordinates\n      } = feature.geometry;\n      let countryName = feature.properties.admin.trim().toLowerCase(); // Use 'admin' property for better matching\n\n      console.log(\"GeoJSON countryName (admin):\", countryName); // Log GeoJSON country name\n\n      // Normalize the country names in countriesData\n      const country = countriesData.find(c => c.name.trim().toLowerCase() === countryName);\n      if (country) {\n        console.log(`Mapping country: ${country.name}`); // Log the country being mapped\n        const countryGroup = new THREE.Group();\n        if (feature.geometry.type === \"Polygon\") {\n          mapPolygonToGlobe(coordinates, countryGroup, country);\n        } else if (feature.geometry.type === \"MultiPolygon\") {\n          coordinates.forEach(polygon => {\n            mapPolygonToGlobe(polygon, countryGroup, country);\n          });\n        }\n        globe.current.add(countryGroup); // Add the country group to the globe\n      } else {\n        console.warn(`Country ${countryName} not found in hardcoded data.`);\n      }\n    });\n  };\n\n  // Helper function to map a single polygon to the globe\n  const mapPolygonToGlobe = (polygon, countryGroup, country) => {\n    polygon.forEach(coordSet => {\n      const points = [];\n      coordSet.forEach(([longitude, latitude]) => {\n        const phi = (90 - latitude) * (Math.PI / 180);\n        const theta = (longitude + 180) * (Math.PI / 180);\n        const x = 5 * Math.sin(phi) * Math.cos(theta);\n        const y = 5 * Math.cos(phi);\n        const z = 5 * Math.sin(phi) * Math.sin(theta);\n        points.push(new THREE.Vector3(x, y, z));\n      });\n      console.log(\"Generated points:\", points); // Log the points generated for each country\n\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\n      const material = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        // White color for country borders\n        linewidth: 1,\n        opacity: 0.8,\n        transparent: true\n      });\n      const line = new THREE.Line(geometry, material);\n\n      // Add the country ID to the userData for later retrieval\n      line.userData = {\n        isCountry: true,\n        id: country.id // Use the country ID from the hardcoded data\n      };\n      countryGroup.add(line);\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      ref: globeRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 230,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CountryModal, {\n      isOpen: !!selectedCountry,\n      countryData: selectedCountry,\n      onClose: () => setSelectedCountry(null)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 229,\n    columnNumber: 5\n  }, this);\n};\n_s(Globe, \"ZkFZl3jVEg9pNGb4YUGYZmPo0Z4=\");\n_c = Globe;\nexport default Globe;\nvar _c;\n$RefreshReg$(_c, \"Globe\");","map":{"version":3,"names":["React","useEffect","useRef","useState","THREE","axios","CountryModal","jsxDEV","_jsxDEV","Globe","_s","globeRef","geoJsonCountries","setGeoJsonCountries","countriesData","setCountriesData","selectedCountry","setSelectedCountry","raycaster","Raycaster","mouse","Vector2","renderer","scene","camera","globe","isDragging","clickStart","get","then","response","console","log","data","map","c","name","toLowerCase","trim","catch","error","fetch","json","geoData","features","current","Scene","PerspectiveCamera","window","innerWidth","innerHeight","WebGLRenderer","setSize","appendChild","domElement","geometry","SphereGeometry","material","MeshBasicMaterial","color","wireframe","Mesh","add","position","z","mapCountriesToGlobe","animate","requestAnimationFrame","rotation","y","render","handleMouseDown","event","x","clientX","clientY","handleMouseMove","deltaMove","Math","abs","handleMouseUp","setFromCamera","intersects","intersectObjects","children","length","clickedObject","object","userData","isCountry","countryId","id","country","find","addEventListener","removeEventListener","forEach","feature","coordinates","countryName","properties","admin","countryGroup","Group","type","mapPolygonToGlobe","polygon","warn","coordSet","points","longitude","latitude","phi","PI","theta","sin","cos","push","Vector3","BufferGeometry","setFromPoints","LineBasicMaterial","linewidth","opacity","transparent","line","Line","ref","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","countryData","onClose","_c","$RefreshReg$"],"sources":["/Users/kietla92/travel-app/front-end/src/components/Globe.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport axios from \"axios\"; // Ensure axios is installed\nimport CountryModal from \"./CountryModal\";\n\nconst Globe = () => {\n  const globeRef = useRef();\n  const [geoJsonCountries, setGeoJsonCountries] = useState([]); // GeoJSON data for globe rendering\n  const [countriesData, setCountriesData] = useState([]); // Detailed data from backend\n  const [selectedCountry, setSelectedCountry] = useState(null);\n\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n\n  const renderer = useRef(null);\n  const scene = useRef(null);\n  const camera = useRef(null);\n  const globe = useRef(null);\n  const isDragging = useRef(false);\n  const clickStart = useRef(null);\n\n  useEffect(() => {\n    // Fetch country details (hardcoded data) from the backend\n    axios\n      .get(\"http://localhost:3000/countries\")\n      .then((response) => {\n        console.log(\"Fetched countriesData:\", response.data); // Log countriesData to check if it's loaded\n        console.log(\n          \"Hardcoded country names:\",\n          countriesData.map((c) => c.name.toLowerCase().trim())\n        );\n\n        setCountriesData(response.data); // Store the detailed countries data from the backend\n      })\n      .catch((error) => {\n        console.error(\"Error fetching countries data:\", error);\n      });\n\n    // Load the GeoJSON file for country borders (for globe rendering)\n    fetch(\"/data/countries.geojson\")\n      .then((response) => response.json())\n      .then((geoData) => {\n        console.log(\"Loaded GeoJSON:\", geoData.features); // Add this to log GeoJSON data\n        setGeoJsonCountries(geoData.features); // Store GeoJSON data\n\n        if (!renderer.current && !scene.current && !camera.current) {\n          scene.current = new THREE.Scene();\n          camera.current = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n          );\n          renderer.current = new THREE.WebGLRenderer();\n          renderer.current.setSize(window.innerWidth, window.innerHeight);\n          globeRef.current.appendChild(renderer.current.domElement);\n\n          const geometry = new THREE.SphereGeometry(5, 32, 32);\n          const material = new THREE.MeshBasicMaterial({\n            color: 0x87ceeb,\n            wireframe: false,\n          });\n          globe.current = new THREE.Mesh(geometry, material);\n          scene.current.add(globe.current);\n\n          camera.current.position.z = 10;\n\n          mapCountriesToGlobe(geoData.features); // Map GeoJSON data to the globe\n\n          const animate = () => {\n            requestAnimationFrame(animate);\n            if (!isDragging.current) {\n              globe.current.rotation.y += 0.01;\n            }\n            renderer.current.render(scene.current, camera.current);\n          };\n          animate();\n        }\n      })\n      .catch((error) => {\n        console.error(\"Error loading GeoJSON:\", error);\n      });\n\n    // Mouse interaction handlers\n    const handleMouseDown = (event) => {\n      isDragging.current = false;\n      clickStart.current = {\n        x: event.clientX,\n        y: event.clientY,\n      };\n    };\n\n    const handleMouseMove = (event) => {\n      if (!clickStart.current) return;\n\n      const deltaMove = {\n        x: event.clientX - clickStart.current.x,\n        y: event.clientY - clickStart.current.y,\n      };\n\n      if (Math.abs(deltaMove.x) > 2 || Math.abs(deltaMove.y) > 2) {\n        isDragging.current = true;\n        globe.current.rotation.y += deltaMove.x * 0.005;\n        globe.current.rotation.x += deltaMove.y * 0.005;\n        clickStart.current = {\n          x: event.clientX,\n          y: event.clientY,\n        };\n      }\n    };\n\n    const handleMouseUp = (event) => {\n      if (!isDragging.current) {\n        const mouse = {\n          x: (event.clientX / window.innerWidth) * 2 - 1,\n          y: -(event.clientY / window.innerHeight) * 2 + 1,\n        };\n        raycaster.setFromCamera(mouse, camera.current);\n\n        const intersects = raycaster.intersectObjects(\n          scene.current.children,\n          true\n        );\n        if (intersects.length > 0) {\n          const clickedObject = intersects[0].object;\n\n          if (\n            clickedObject &&\n            clickedObject.userData &&\n            clickedObject.userData.isCountry\n          ) {\n            const countryId = clickedObject.userData.id; // Get the country ID from userData\n\n            // Find the country in the fetched countries data\n            const country = countriesData.find((c) => c.id === countryId);\n\n            if (country) {\n              setSelectedCountry(country); // Show country details in modal\n            }\n          }\n        }\n      }\n\n      clickStart.current = null;\n      isDragging.current = false;\n    };\n\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [countriesData]);\n\n  // Function to map GeoJSON countries onto the globe\n  const mapCountriesToGlobe = (features) => {\n    features.forEach((feature) => {\n      const { coordinates } = feature.geometry;\n      let countryName = feature.properties.admin.trim().toLowerCase(); // Use 'admin' property for better matching\n\n      console.log(\"GeoJSON countryName (admin):\", countryName); // Log GeoJSON country name\n\n      // Normalize the country names in countriesData\n      const country = countriesData.find(\n        (c) => c.name.trim().toLowerCase() === countryName\n      );\n\n      if (country) {\n        console.log(`Mapping country: ${country.name}`); // Log the country being mapped\n        const countryGroup = new THREE.Group();\n\n        if (feature.geometry.type === \"Polygon\") {\n          mapPolygonToGlobe(coordinates, countryGroup, country);\n        } else if (feature.geometry.type === \"MultiPolygon\") {\n          coordinates.forEach((polygon) => {\n            mapPolygonToGlobe(polygon, countryGroup, country);\n          });\n        }\n\n        globe.current.add(countryGroup); // Add the country group to the globe\n      } else {\n        console.warn(`Country ${countryName} not found in hardcoded data.`);\n      }\n    });\n  };\n\n  // Helper function to map a single polygon to the globe\n  const mapPolygonToGlobe = (polygon, countryGroup, country) => {\n    polygon.forEach((coordSet) => {\n      const points = [];\n\n      coordSet.forEach(([longitude, latitude]) => {\n        const phi = (90 - latitude) * (Math.PI / 180);\n        const theta = (longitude + 180) * (Math.PI / 180);\n\n        const x = 5 * Math.sin(phi) * Math.cos(theta);\n        const y = 5 * Math.cos(phi);\n        const z = 5 * Math.sin(phi) * Math.sin(theta);\n\n        points.push(new THREE.Vector3(x, y, z));\n      });\n\n      console.log(\"Generated points:\", points); // Log the points generated for each country\n\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\n      const material = new THREE.LineBasicMaterial({\n        color: 0xffffff, // White color for country borders\n        linewidth: 1,\n        opacity: 0.8,\n        transparent: true,\n      });\n      const line = new THREE.Line(geometry, material);\n\n      // Add the country ID to the userData for later retrieval\n      line.userData = {\n        isCountry: true,\n        id: country.id, // Use the country ID from the hardcoded data\n      };\n\n      countryGroup.add(line);\n    });\n  };\n\n  return (\n    <div>\n      <div ref={globeRef} />\n      <CountryModal\n        isOpen={!!selectedCountry}\n        countryData={selectedCountry}\n        onClose={() => setSelectedCountry(null)}\n      />\n    </div>\n  );\n};\n\nexport default Globe;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}